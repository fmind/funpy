!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Mode	funpy/io.py	/^Mode = str$/;"	v
Path	funpy/io.py	/^Path = str$/;"	v
Pool	funpy/pp.py	/^Pool = Type[futures.Executor]$/;"	v
Predicate	funpy/fn.py	/^Predicate = Callable[..., bool]$/;"	v
ProcessPool	funpy/pp.py	/^ProcessPool = futures.ProcessPoolExecutor$/;"	v
ThreadPool	funpy/pp.py	/^ThreadPool = futures.ThreadPoolExecutor$/;"	v
X	funpy/fn.py	/^X = TypeVar("X")$/;"	v
Y	funpy/fn.py	/^Y = TypeVar("Y")$/;"	v
Z	funpy/fn.py	/^Z = TypeVar("Z")$/;"	v
abs	funpy/op.py	/^abs = operator.abs$/;"	v
accumulate	funpy/it.py	/^accumulate = itertools.accumulate$/;"	v
add	funpy/op.py	/^add = operator.add$/;"	v
addseq	funpy/op.py	/^addseq = operator.concat$/;"	v
all	funpy/it.py	/^all = builtins.all$/;"	v
and_	funpy/op.py	/^and_ = operator.and_$/;"	v
any	funpy/it.py	/^any = builtins.any$/;"	v
author	setup.py	/^    author="Médéric Hurier",$/;"	v
author_email	setup.py	/^    author_email="dev@fmind.me",$/;"	v
butlast	funpy/it.py	/^def butlast(l: Iterable) -> Iterator:$/;"	f
c	ipython.py	/^c = get_config()$/;"	v
c	shells/ipython.py	/^c = get_config()$/;"	v
cat	funpy/it.py	/^cat = itertools.chain$/;"	v
ceil	funpy/op.py	/^ceil = math.ceil$/;"	v
chunk	funpy/it.py	/^def chunk(l: Iterable, n: int) -> Iterator[tuple]:$/;"	f
chunkall	funpy/it.py	/^def chunkall(l: Iterable, n: int) -> Iterator[tuple]:$/;"	f
chunkby	funpy/it.py	/^def chunkby(l: Iterable, p: fn.Predicate = bool) -> Iterator[tuple]:$/;"	f
classifiers	setup.py	/^    classifiers=[$/;"	v
combinations	funpy/it.py	/^combinations = itertools.combinations$/;"	v
combinatoric	funpy/it.py	/^combinatoric = itertools.combinations_with_replacement$/;"	v
combine	funpy/io.py	/^combine = fileinput.input$/;"	v
comp	funpy/fn.py	/^def comp(*fs: Callable) -> Callable:$/;"	f
comparator	funpy/fn.py	/^comparator = functools.cmp_to_key$/;"	v
complement	funpy/fn.py	/^def complement(p: Predicate) -> Predicate:$/;"	f
compose	funpy/fn.py	/^def compose(f: Callable[[Z], Y], g: Callable[..., Z]) -> Callable[..., Y]:$/;"	f
composed	funpy/fn.py	/^    def composed(*args, **kwargs):$/;"	f	function:compose
compress	funpy/it.py	/^compress = itertools.compress$/;"	v
concat	funpy/it.py	/^concat = itertools.chain.from_iterable$/;"	v
conj	funpy/it.py	/^def conj(l: Iterable, x: Any) -> Iterator:$/;"	f
cons	funpy/it.py	/^def cons(l: Iterable, x: Any) -> Iterator:$/;"	f
constant	funpy/fn.py	/^    def constant(*_, **__):$/;"	f	function:constantly
constantly	funpy/fn.py	/^def constantly(x: X) -> Callable[..., X]:$/;"	f
consume	funpy/it.py	/^def consume(l: Iterable) -> None:$/;"	f
contains	funpy/it.py	/^def contains(l: Iterable, x: Any) -> bool:$/;"	f
copies	funpy/fn.py	/^def copies(x: X, n: int = 2, deep: bool = False) -> Iterable[X]:$/;"	f
copy	funpy/fn.py	/^def copy(x: X, deep: bool = False) -> X:$/;"	f
cos	funpy/op.py	/^cos = math.cos$/;"	v
count	funpy/it.py	/^count = itertools.count$/;"	v
count	funpy/op.py	/^count = operator.countOf$/;"	v
cycle	funpy/it.py	/^cycle = itertools.cycle$/;"	v
dec	funpy/op.py	/^def dec(x: int) -> int:$/;"	f
dedent	funpy/io.py	/^dedent = textwrap.dedent$/;"	v
dedupe	funpy/it.py	/^def dedupe(l: Iterable, f: Callable = fn.ident) -> Iterator:$/;"	f
degrees	funpy/op.py	/^degrees = math.degrees$/;"	v
description	setup.py	/^    description="Functional and Pythonic stdlib.",$/;"	v
distinct	funpy/it.py	/^def distinct(l: Iterable, f: Callable = fn.ident) -> Iterator:$/;"	f
div	funpy/op.py	/^div = fractions.Fraction$/;"	v
drop	funpy/it.py	/^def drop(l: Iterable, n: int) -> Iterator:$/;"	f
droplast	funpy/it.py	/^def droplast(l: Iterable, n: int) -> Iterator:$/;"	f
dropnth	funpy/it.py	/^def dropnth(l: Iterable, n: int) -> Iterator:$/;"	f
dropwhile	funpy/it.py	/^dropwhile = itertools.dropwhile$/;"	v
e	funpy/op.py	/^e = math.e$/;"	v
enumerate	funpy/it.py	/^enumerate = builtins.enumerate$/;"	v
eq	funpy/op.py	/^eq = operator.eq$/;"	v
exp	funpy/op.py	/^exp = math.exp$/;"	v
extras_require	setup.py	/^    extras_require={$/;"	v
factorial	funpy/op.py	/^factorial = math.factorial$/;"	v
fill	funpy/io.py	/^fill = textwrap.fill$/;"	v
filter	funpy/it.py	/^filter = builtins.filter$/;"	v
find	funpy/it.py	/^def find(l: Iterable, p: fn.Predicate = bool, d: Any = None) -> Optional[Any]:$/;"	f
first	funpy/it.py	/^def first(l: Iterable, d: Any = None) -> Optional[Any]:$/;"	f
flip	funpy/fn.py	/^def flip(f: Callable[..., Y]) -> Callable[..., Y]:$/;"	f
floor	funpy/op.py	/^floor = math.floor$/;"	v
floordiv	funpy/op.py	/^floordiv = operator.floordiv$/;"	v
fluent	funpy/fn.py	/^def fluent(f: Callable[..., None]) -> Callable:$/;"	f
fnil	funpy/fn.py	/^def fnil(f: Callable[..., Y], x: X) -> Callable[..., Y]:$/;"	f
gcd	funpy/op.py	/^gcd = math.gcd$/;"	v
ge	funpy/op.py	/^ge = operator.ge$/;"	v
getat	funpy/op.py	/^getat = operator.attrgetter$/;"	v
getit	funpy/op.py	/^getit = operator.itemgetter$/;"	v
getme	funpy/op.py	/^getme = operator.methodcaller$/;"	v
glob	funpy/io.py	/^glob = Glob.glob$/;"	v
groupby	funpy/it.py	/^groupby = itertools.groupby$/;"	v
grouped	funpy/it.py	/^def grouped($/;"	f
groupkv	funpy/it.py	/^def groupkv(l: Iterable):$/;"	f
gt	funpy/op.py	/^gt = operator.gt$/;"	v
hasat	funpy/op.py	/^hasat = builtins.hasattr$/;"	v
hypot	funpy/op.py	/^hypot = math.hypot$/;"	v
ident	funpy/fn.py	/^def ident(x: X) -> X:$/;"	f
iglob	funpy/io.py	/^iglob = Glob.iglob$/;"	v
inc	funpy/op.py	/^def inc(x: int) -> int:$/;"	f
indent	funpy/io.py	/^indent = textwrap.indent$/;"	v
index	funpy/op.py	/^index = operator.indexOf$/;"	v
inf	funpy/op.py	/^inf = math.inf$/;"	v
info	setup.py	/^info = dict($/;"	v
install_requires	setup.py	/^    install_requires=requires(),$/;"	v
interact	funpy/io.py	/^def interact($/;"	f
interchange	funpy/it.py	/^def interchange(*ls: Iterable, x: Any = None) -> Iterator:$/;"	f
interleave	funpy/it.py	/^def interleave(*ls: Iterable) -> Iterator:$/;"	f
interpose	funpy/it.py	/^def interpose(l: Iterable, x: Any) -> Iterator:$/;"	f
inv	funpy/op.py	/^inv = operator.inv$/;"	v
is_	funpy/op.py	/^is_ = operator.is_$/;"	v
isa	funpy/op.py	/^isa = builtins.isinstance$/;"	v
isclose	funpy/op.py	/^isclose = math.isclose$/;"	v
isempty	funpy/op.py	/^def isempty(l: Sized) -> bool:$/;"	f
iseven	funpy/op.py	/^def iseven(x: int) -> bool:$/;"	f
isfalse	funpy/op.py	/^def isfalse(x: Any) -> bool:$/;"	f
isfinite	funpy/op.py	/^isfinite = math.isfinite$/;"	v
isin	funpy/op.py	/^isin = operator.contains$/;"	v
isinf	funpy/op.py	/^isinf = math.isinf$/;"	v
isnan	funpy/op.py	/^isnan = math.isnan$/;"	v
isneg	funpy/op.py	/^def isneg(x: int) -> bool:$/;"	f
isnone	funpy/op.py	/^def isnone(x: Any) -> bool:$/;"	f
isnot	funpy/op.py	/^isnot = operator.is_not$/;"	v
isodd	funpy/op.py	/^def isodd(x: int) -> bool:$/;"	f
ispos	funpy/op.py	/^def ispos(x: int) -> bool:$/;"	f
issome	funpy/op.py	/^def issome(x: Any) -> bool:$/;"	f
issub	funpy/op.py	/^issub = builtins.issubclass$/;"	v
istrue	funpy/op.py	/^istrue = operator.truth$/;"	v
iszero	funpy/op.py	/^def iszero(x: int) -> bool:$/;"	f
iterate	funpy/it.py	/^def iterate(f: Callable, x: Any) -> Iterator:$/;"	f
iterwith	funpy/it.py	/^def iterwith(x: Any) -> Iterator:$/;"	f
juxt	funpy/fn.py	/^def juxt(*fs: Callable) -> Callable[..., tuple]:$/;"	f
juxted	funpy/fn.py	/^    def juxted(*args, **kwargs):$/;"	f	function:juxt
keywords	setup.py	/^    keywords="operator function iterator parallel io",$/;"	v
last	funpy/it.py	/^def last(it: Iterable, d: Any = None) -> Optional[Any]:$/;"	f
le	funpy/op.py	/^le = operator.le$/;"	v
len	funpy/it.py	/^def len(l: Iterable) -> int:$/;"	f
license	setup.py	/^    license="AGPL-3.0",$/;"	v
lines	funpy/io.py	/^def lines(s: str) -> Iterator[str]:$/;"	f
locate	funpy/it.py	/^def locate(l: Iterable, p: fn.Predicate = bool):$/;"	f
log	funpy/op.py	/^log = math.log$/;"	v
log10	funpy/op.py	/^log10 = math.log10$/;"	v
log2	funpy/op.py	/^log2 = math.log2$/;"	v
long_description	setup.py	/^    long_description=open("README.md", "r").read(),$/;"	v
long_description_content_type	setup.py	/^    long_description_content_type="text\/markdown",$/;"	v
lshift	funpy/op.py	/^lshift = operator.lshift$/;"	v
lt	funpy/op.py	/^lt = operator.lt$/;"	v
map	funpy/it.py	/^map = builtins.map$/;"	v
mapcat	funpy/it.py	/^def mapcat(f: Callable, *ls: Iterable) -> Iterator:$/;"	f
mapevery	funpy/it.py	/^def mapevery(f: Callable, n: int, *ls: Iterable) -> Iterator:$/;"	f
mapreduce	funpy/pp.py	/^def mapreduce($/;"	f
matmul	funpy/op.py	/^matmul = operator.matmul$/;"	v
max	funpy/it.py	/^max = builtins.max$/;"	v
means	funpy/op.py	/^means = statistics.mean$/;"	v
median	funpy/op.py	/^median = statistics.median$/;"	v
member	funpy/it.py	/^def member(l: Iterable, s: Container) -> Iterator:$/;"	f
memoize	funpy/fn.py	/^memoize = functools.lru_cache$/;"	v
min	funpy/it.py	/^min = builtins.min$/;"	v
mod	funpy/op.py	/^mod = operator.mod$/;"	v
mode	funpy/op.py	/^mode = statistics.mode$/;"	v
mul	funpy/op.py	/^mul = operator.mul$/;"	v
mult	funpy/it.py	/^def mult(l: Iterable, start: Any = 1) -> Any:$/;"	f
name	setup.py	/^    name="funpy",$/;"	v
nan	funpy/op.py	/^nan = math.nan$/;"	v
ne	funpy/op.py	/^ne = operator.ne$/;"	v
neg	funpy/op.py	/^neg = operator.neg$/;"	v
not_	funpy/op.py	/^not_ = operator.not_$/;"	v
notempty	funpy/op.py	/^def notempty(l: Sized) -> bool:$/;"	f
notin	funpy/op.py	/^def notin(l: Container, x: Any) -> bool:$/;"	f
nth	funpy/it.py	/^def nth(l: Iterable, n: int, d: Any = None) -> Optional[Any]:$/;"	f
or_	funpy/op.py	/^or_ = operator.or_$/;"	v
packages	setup.py	/^    packages=["funpy"],$/;"	v
pad	funpy/it.py	/^def pad(l: Iterable, d: Any = None) -> Iterator:$/;"	f
partial	funpy/fn.py	/^partial = functools.partial$/;"	v
partialfp	funpy/fn.py	/^def partialfp(f: Callable[..., Y], *args, **kwargs) -> Callable[..., Y]:$/;"	f
partialme	funpy/fn.py	/^partialme = functools.partialmethod$/;"	v
permutated	funpy/it.py	/^permutated = itertools.permutations$/;"	v
permutations	funpy/it.py	/^permutations = itertools.permutations$/;"	v
pi	funpy/op.py	/^pi = math.pi$/;"	v
pmap	funpy/pp.py	/^def pmap($/;"	f
pos	funpy/op.py	/^pos = operator.pos$/;"	v
post	funpy/fn.py	/^def post($/;"	f
pow	funpy/op.py	/^pow = builtins.pow$/;"	v
pprint	funpy/io.py	/^pprint = Print.pprint$/;"	v
pre	funpy/fn.py	/^def pre($/;"	f
product	funpy/it.py	/^product = itertools.product$/;"	v
pure	funpy/fn.py	/^def pure(f: Callable[..., None], deep: bool = False) -> Callable:$/;"	f
quantify	funpy/it.py	/^def quantify(l: Iterable, p: fn.Predicate = bool) -> int:$/;"	f
radians	funpy/op.py	/^radians = math.radians$/;"	v
range	funpy/it.py	/^range = builtins.range$/;"	v
reduce	funpy/it.py	/^reduce = functools.reduce$/;"	v
remove	funpy/it.py	/^remove = itertools.filterfalse$/;"	v
repeat	funpy/it.py	/^repeat = itertools.repeat$/;"	v
replace	funpy/it.py	/^def replace(l: Iterable, m: dict, d: Any = None) -> Iterator:$/;"	f
requires	setup.py	/^def requires(requirements="requirements.txt"):$/;"	f
rest	funpy/it.py	/^def rest(l: Iterable) -> Iterator:$/;"	f
reversed	funpy/it.py	/^reversed = builtins.reversed$/;"	v
root	setup.py	/^root = os.path.abspath(os.path.dirname(__file__))$/;"	v
round	funpy/op.py	/^round = builtins.round$/;"	v
rshift	funpy/op.py	/^rshift = operator.rshift$/;"	v
safe	funpy/fn.py	/^def safe(f: Callable[..., Y], x: Z = None) -> Callable[..., Union[Y, Z]]:$/;"	f
second	funpy/it.py	/^def second(l: Iterable, d: Any = None) -> Optional[Any]:$/;"	f
shorten	funpy/io.py	/^shorten = textwrap.shorten$/;"	v
sin	funpy/op.py	/^sin = math.sin$/;"	v
singledispatch	funpy/fn.py	/^singledispatch = functools.singledispatch$/;"	v
slice	funpy/it.py	/^slice = itertools.islice$/;"	v
slide	funpy/it.py	/^def slide(l: Iterable, n: int) -> Iterator[tuple]:$/;"	f
slurp	funpy/io.py	/^def slurp(path: Path, mode: Mode = "r") -> AnyStr:$/;"	f
sorted	funpy/it.py	/^sorted = builtins.sorted$/;"	v
spit	funpy/io.py	/^def spit(path: Path, s: AnyStr, mode: Mode = "w") -> None:$/;"	f
split	funpy/it.py	/^def split(l: Iterable, n: int) -> Tuple[Iterator, Iterator]:$/;"	f
splitby	funpy/it.py	/^def splitby(l: Iterable, p: fn.Predicate = bool) -> Tuple[Iterator, Iterator]:$/;"	f
sqrt	funpy/op.py	/^sqrt = math.sqrt$/;"	v
starmap	funpy/it.py	/^starmap = itertools.starmap$/;"	v
stdev	funpy/op.py	/^stdev = statistics.stdev$/;"	v
sub	funpy/it.py	/^def sub(l: Iterable, start: int, stop: int) -> Iterator:$/;"	f
sub	funpy/op.py	/^sub = operator.sub$/;"	v
sum	funpy/it.py	/^sum = builtins.sum$/;"	v
tabulate	funpy/it.py	/^def tabulate(f: Callable, start: int = 0, step: int = 1) -> Iterator:$/;"	f
take	funpy/it.py	/^def take(l: Iterable, n: int) -> Iterator:$/;"	f
takelast	funpy/it.py	/^def takelast(l: Iterable, n: int) -> Iterator:$/;"	f
takenth	funpy/it.py	/^def takenth(l: Iterable, n: int, start: int = 0, end: int = None) -> Iterator:$/;"	f
takewhile	funpy/it.py	/^takewhile = itertools.takewhile$/;"	v
tan	funpy/op.py	/^tan = math.tan$/;"	v
tau	funpy/op.py	/^tau = math.tau$/;"	v
tee	funpy/it.py	/^tee = itertools.tee$/;"	v
test_error	tests/test_example.py	/^def test_error():$/;"	f
test_success	tests/test_example.py	/^def test_success():$/;"	f
third	funpy/it.py	/^def third(l: Iterable, d: Any = None) -> Optional[Any]:$/;"	f
totalordering	funpy/fn.py	/^totalordering = functools.total_ordering$/;"	v
transpose	funpy/it.py	/^transpose = builtins.zip$/;"	v
truediv	funpy/op.py	/^truediv = operator.truediv$/;"	v
unbl	funpy/io.py	/^def unbl(l: Iterable[str]) -> Iterator[str]:$/;"	f
unlines	funpy/io.py	/^def unlines(l: Iterable[str]) -> str:$/;"	f
unnl	funpy/io.py	/^def unnl(l: Iterable[str]) -> Iterator[str]:$/;"	f
unwords	funpy/io.py	/^def unwords(l: Iterable[str]) -> str:$/;"	f
url	setup.py	/^    url="https:\/\/git.fmind.me\/fmind\/funpy",$/;"	v
variance	funpy/op.py	/^variance = statistics.variance$/;"	v
version	setup.py	/^    version="0.5.5",$/;"	v
window	funpy/it.py	/^    def window(x):$/;"	f	function:slide
words	funpy/io.py	/^def words(s: str) -> Iterator[str]:$/;"	f
wrap	funpy/io.py	/^wrap = textwrap.wrap$/;"	v
wrapped	funpy/fn.py	/^    def wrapped(*args, **kwargs):$/;"	f	function:complement
wrapped	funpy/fn.py	/^    def wrapped(*args, **kwargs):$/;"	f	function:flip
wrapped	funpy/fn.py	/^    def wrapped(*args, **kwargs):$/;"	f	function:post
wrapped	funpy/fn.py	/^    def wrapped(*args, **kwargs):$/;"	f	function:pre
wrapped	funpy/fn.py	/^    def wrapped(*args, **kwargs):$/;"	f	function:safe
wrapped	funpy/fn.py	/^    def wrapped(x, *args, **kwargs):$/;"	f	function:fluent
wrapped	funpy/fn.py	/^    def wrapped(x, *args, **kwargs):$/;"	f	function:pure
wrapped	funpy/fn.py	/^    def wrapped(z: X, *args, **kwargs):$/;"	f	function:fnil
wraps	funpy/fn.py	/^wraps = functools.wraps$/;"	v
xor	funpy/op.py	/^xor = operator.xor$/;"	v
zip	funpy/it.py	/^zip = builtins.zip$/;"	v
ziplong	funpy/it.py	/^ziplong = itertools.zip_longest$/;"	v
